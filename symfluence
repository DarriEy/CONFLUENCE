#!/bin/bash
#
# SYMFLUENCE Shell Wrapper with Python Environment Management
#
# Usage: symfluence [options]
# Example: symfluence --install
#
set -e

# ----------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------
SCRIPT_NAME="symfluence"
SYMFLUENCE_SCRIPT="symfluence.py"
MIN_PYTHON_VERSION="3.11"
REQUIRED_PYTHON_VERSION="3.11"

# ----------------------------------------------------------------------
# Colors
# ----------------------------------------------------------------------
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''; GREEN=''; YELLOW=''; BLUE=''; NC='';
fi

print_error()   { echo -e "${RED}Error:${NC} $1" >&2; }
print_warning() { echo -e "${YELLOW}Warning:${NC} $1" >&2; }
print_info()    { echo -e "${BLUE}Info:${NC} $1"; }
print_success() { echo -e "${GREEN}Success:${NC} $1"; }

# ----------------------------------------------------------------------
# R / rpy2 environment helpers (enhanced)
# ----------------------------------------------------------------------
setup_r_environment() {
    print_info "Auto-detecting R environment..."

    if ! command -v R >/dev/null 2>&1; then
        print_error "R is not available in PATH"
        print_info  "Please load R module before running installation, e.g.:"
        print_info  "  module load r/4.5.0  # or your platform's R module"
        return 1
    fi

    local r_version
    r_version=$(R --version | head -1 || true)
    [[ -n "$r_version" ]] && print_success "Found R: $r_version"

    if [[ -z "$R_HOME" ]]; then
        print_info "R_HOME not set, auto-detecting..."
        local detected_r_home
        detected_r_home=$(R RHOME 2>/dev/null || true)
        if [[ -n "$detected_r_home" && -d "$detected_r_home" ]]; then
            export R_HOME="$detected_r_home"
            print_success "Set R_HOME=$R_HOME"
        else
            print_warning "Could not detect R_HOME"
            print_info    "You may need to set it manually: export R_HOME=\$(R RHOME)"
        fi
    else
        print_success "R_HOME already set: $R_HOME"
    fi

    if [[ -n "$R_HOME" && -d "$R_HOME/lib" ]]; then
        if [[ ":$LD_LIBRARY_PATH:" != *":$R_HOME/lib:"* ]]; then
            export LD_LIBRARY_PATH="$R_HOME/lib:${LD_LIBRARY_PATH:-}"
            print_info "Added $R_HOME/lib to LD_LIBRARY_PATH"
        fi
    fi

    setup_rpy2_compiler_flags
    check_rpy2_dependencies
    return 0
}

setup_rpy2_compiler_flags() {
    print_info "Setting up compiler environment for rpy2..."
    local lib_paths=()
    if [[ -n "$LD_LIBRARY_PATH" ]]; then IFS=':' read -ra _p <<< "$LD_LIBRARY_PATH"; lib_paths+=("${_p[@]}"); fi
    if [[ -n "$LIBRARY_PATH" ]]; then IFS=':' read -ra _p <<< "$LIBRARY_PATH"; lib_paths+=("${_p[@]}"); fi

    local potential_lib_dirs=("/usr/lib64" "/usr/lib" "/lib64" "/lib")
    for d in "${potential_lib_dirs[@]}"; do [[ -d "$d" ]] && lib_paths+=("$d"); done

    for prog in xz bzip2; do
        if command -v "$prog" >/dev/null 2>&1; then
            local p dir
            p=$(dirname "$(command -v "$prog")")
            for dir in ../lib ../lib64; do
                [[ -d "$p/$dir" ]] && lib_paths+=("$(cd "$p/$dir" && pwd)")
            done
        fi
    done

    local ldflags="" cflags="" seen=()
    for path in "${lib_paths[@]}"; do
        if [[ -d "$path" && ! " ${seen[*]} " =~ " $path " ]]; then
            seen+=("$path")
            ldflags="$ldflags -L$path"
            local inc="${path/lib/include}"
            [[ -d "$inc" ]] && cflags="$cflags -I$inc"
        fi
    done
    [[ -n "$ldflags" ]] && export LDFLAGS="$ldflags ${LDFLAGS:-}" && print_info "Set LDFLAGS for rpy2 compilation"
    [[ -n "$cflags" ]] && export CFLAGS="$cflags ${CFLAGS:-}" && print_info "Set CFLAGS for rpy2 compilation"
}

check_rpy2_dependencies() {
    print_info "Checking for libraries required by rpy2..."
    local required_libs=("lzma" "bz2" "z" "tirpc")
    local missing=() found=()

    if command -v ldconfig >/dev/null 2>&1; then
        for lib in "${required_libs[@]}"; do
            ldconfig -p 2>/dev/null | grep -q "lib${lib}\.so" && found+=("$lib") || missing+=("$lib")
        done
    else
        local search=("/usr/lib" "/usr/lib64" "/lib" "/lib64")
        [[ -n "$LD_LIBRARY_PATH" ]] && IFS=':' read -ra _a <<< "$LD_LIBRARY_PATH" && search+=("${_a[@]}")
        [[ -n "$LIBRARY_PATH" ]] && IFS=':' read -ra _b <<< "$LIBRARY_PATH" && search+=("${_b[@]}")
        for lib in "${required_libs[@]}"; do
            local ok=false
            for p in "${search[@]}"; do
                [[ -f "$p/lib${lib}.so" || -f "$p/lib${lib}.a" ]] && ok=true && break
            done
            $ok && found+=("$lib") || missing+=("$lib")
        done
    fi

    [[ ${#found[@]} -gt 0 ]] && print_success "Found libraries: ${found[*]}"
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_warning "Could not detect libraries: ${missing[*]}"
        print_info "Load modules providing these before install (examples):"
        for lib in "${missing[@]}"; do
            case "$lib" in
                lzma)  print_info "  module load xz" ;;
                bz2)   print_info "  module load bzip2" ;;
                tirpc) print_info "  module load libtirpc" ;;
                z)     print_info "  module load zlib" ;;
            esac
        done
        read -p "Press Enter to continue anyway, or Ctrl+C to abort..." _tmp || true
    fi
}

install_gdal_python() {
    print_info "Detecting system GDAL version..."
    if ! command -v gdal-config >/dev/null 2>&1; then
        print_warning "gdal-config not found; skipping GDAL Python bindings"
        return 0
    fi
    local v
    v=$(gdal-config --version 2>/dev/null || true)
    [[ -z "$v" ]] && { print_warning "Could not detect GDAL version"; return 0; }
    print_success "Found system GDAL: $v"
    print_info "Installing matching GDAL Python bindings..."

    if pip install "GDAL==$v"; then
        print_success "Installed GDAL Python bindings $v"
        return 0
    fi

    local mm
    mm=$(echo "$v" | cut -d. -f1,2)
    print_info "Trying GDAL>=$mm.0,<$mm.99..."
    if pip install "GDAL>=${mm}.0,<${mm}.99"; then
        print_success "Installed GDAL Python bindings for $mm.x"
        return 0
    fi

    print_error "Failed to install GDAL Python bindings. You may try: pip install GDAL==$v"
    return 1
}

install_python_requirements() {
    local req="$1"; local use_break="${2:-true}"
    [[ ! -f "$req" ]] && { print_error "Requirements file not found: $req"; return 1; }

    local pip_flags=""
    if [[ -z "$VIRTUAL_ENV" && -z "$CONDA_DEFAULT_ENV" && "$use_break" == "true" ]]; then
        pip_flags="--break-system-packages"
    fi

    print_info "Installing Python dependencies from: $req"
    local tmp="${req}.tmp"

    # Filter out GDAL and rpy2 from the pass, we’ll handle them explicitly
    grep -v -iE "^(GDAL|rpy2)([>=<~!]|$)" "$req" > "$tmp" 2>/dev/null || cp "$req" "$tmp"
    local gdal_filtered=false rpy2_filtered=false
    grep -qiE "^GDAL([>=<~!]|$)" "$req" && gdal_filtered=true
    grep -qiE "^rpy2([>=<~!]|$)" "$req" && rpy2_filtered=true

    # Try API mode first
    [[ -z "$RPY2_CFFI_MODE" ]] && export RPY2_CFFI_MODE=API

    if pip install -r "$tmp" $pip_flags; then
        rm -f "$tmp"
        [[ "$gdal_filtered" == "true" ]] && install_gdal_python || true
        if [[ "$rpy2_filtered" == "true" ]]; then
            print_info "Attempting rpy2 install (RPY2_CFFI_MODE=$RPY2_CFFI_MODE)..."
            pip install rpy2 $pip_flags || print_warning "rpy2 install failed (continuing)"
        fi
        command -v gdal-config >/dev/null 2>&1 && install_gdal_python || true
        print_success "Core dependencies installed"
        return 0
    fi

    # Retry with ABI mode
    print_warning "Install failed with RPY2_CFFI_MODE=$RPY2_CFFI_MODE; retrying with ABI..."
    export RPY2_CFFI_MODE=ABI
    if pip install -r "$tmp" $pip_flags; then
        rm -f "$tmp"
        [[ "$gdal_filtered" == "true" ]] && install_gdal_python || true
        if [[ "$rpy2_filtered" == "true" ]]; then
            print_info "Attempting rpy2 install in ABI mode..."
            pip install rpy2 $pip_flags || print_warning "rpy2 install failed (continuing)"
        fi
        command -v gdal-config >/dev/null 2>&1 && install_gdal_python || true
        print_success "Dependencies installed in ABI mode"
        return 0
    fi

    rm -f "$tmp"
    print_error "Failed to install dependencies"
    return 1
}

# ----------------------------------------------------------------------
# Locate symfluence.py (with legacy env var compat)
# ----------------------------------------------------------------------
find_symfluence_script() {
    local script_dir
    script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")

    local search_paths=(
        "${script_dir}/${SYMFLUENCE_SCRIPT}"
        "${script_dir}/../${SYMFLUENCE_SCRIPT}"
        "./${SYMFLUENCE_SCRIPT}"
        "${PWD}/${SYMFLUENCE_SCRIPT}"
    )

    if [[ -n "${SYMFLUENCE_CODE_DIR}" ]]; then
        search_paths=("${SYMFLUENCE_CODE_DIR}/${SYMFLUENCE_SCRIPT}" "${search_paths[@]}")
    elif [[ -n "${CONFLUENCE_CODE_DIR}" ]]; then
        search_paths=("${CONFLUENCE_CODE_DIR}/${SYMFLUENCE_SCRIPT}" "${search_paths[@]}")
    fi

    local path
    for path in "${search_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    return 1
}

# ----------------------------------------------------------------------
# Python finder (prefers 3.11–3.13; rejects 3.14+)
# ----------------------------------------------------------------------
find_python() {
    local python_candidates=("python3.11" "python3.12" "python3.13" "python3.10" "python3" "python")
    local cmd version major minor
    for cmd in "${python_candidates[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            version=$($cmd -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || true)
            if [[ -n "$version" ]]; then
                major=${version%%.*}
                minor=${version#*.}
                if [[ "$major" -eq 3 && "$minor" -gt 13 ]]; then
                    continue
                fi
                if $cmd -c "import sys; current=tuple(map(int,'$version'.split('.'))); required=tuple(map(int,'$MIN_PYTHON_VERSION'.split('.'))); import sys; sys.exit(0 if current>=required else 1)" 2>/dev/null; then
                    echo "$cmd"
                    return 0
                fi
            fi
        fi
    done
    return 1
}

# ----------------------------------------------------------------------
# Virtual env activator (clears PYTHONPATH)
# ----------------------------------------------------------------------
check_virtual_env() {
    local symfluence_dir
    symfluence_dir=$(dirname "$1")
    local venv_paths=(
        "${symfluence_dir}/venv"
        "${symfluence_dir}/.venv"
        "${symfluence_dir}/env"
        "${symfluence_dir}/.env"
    )

    if [[ -n "${VIRTUAL_ENV}" ]]; then
        print_info "Using active virtual environment: ${VIRTUAL_ENV}"
        return 0
    fi

    local venv_path
    for venv_path in "${venv_paths[@]}"; do
        if [[ -f "${venv_path}/bin/activate" ]]; then
            print_info "Found virtual environment: ${venv_path}"
            print_info "Activating virtual environment..."
            source "${venv_path}/bin/activate"
            if [[ -n "$PYTHONPATH" ]]; then
                export PYTHONPATH=""
            fi
            return 0
        fi
    done
    return 0
}

# ----------------------------------------------------------------------
# Wrapper UX
# ----------------------------------------------------------------------
show_symfluence_help() {
    cat << EOF
${SCRIPT_NAME}: SYMFLUENCE Python script not found

This wrapper looks for symfluence.py in:
  - Current directory and parent directories
  - \$SYMFLUENCE_CODE_DIR (preferred)
  - \$CONFLUENCE_CODE_DIR (legacy)

Fix:
  1) Run this from the SYMFLUENCE project dir, or
  2) export SYMFLUENCE_CODE_DIR=/path/to/symfluence

Docs: https://github.com/DarriEy/symfluence
EOF
}

handle_wrapper_flags() {
    case "$1" in
        --wrapper-help)
            cat << EOF
SYMFLUENCE Shell Wrapper Help

Wrapper-only options:
  --wrapper-help     Show this help message
  --wrapper-info     Show wrapper and environment information
  --wrapper-debug    Run wrapper in debug mode
  --install          Set up Python environment and install external tools

All other options are passed to symfluence.py (see 'symfluence --help').
EOF
            exit 0
            ;;
        --wrapper-info)
            local symfluence_script
            symfluence_script=$(find_symfluence_script || true)
            local python_cmd
            python_cmd=$(find_python || true)

            echo "SYMFLUENCE Wrapper Information"
            echo "=============================="
            echo "Wrapper script: $(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
            echo "symfluence.py: ${symfluence_script:-'Not found'}"
            echo "Python command: ${python_cmd:-'Not found'}"
            echo "Python version: $(${python_cmd} --version 2>/dev/null || echo 'Unknown')"
            echo "Virtual env: ${VIRTUAL_ENV:-'None active'}"
            echo "Working directory: $(pwd)"
            echo "SYMFLUENCE_CODE_DIR: ${SYMFLUENCE_CODE_DIR:-'Not set'}"
            echo "CONFLUENCE_CODE_DIR (legacy): ${CONFLUENCE_CODE_DIR:-'Not set'}"
            exit 0
            ;;
        --wrapper-debug) set -x; return 1 ;;
        --install)       return 1 ;;
        *)               return 1 ;;
    esac
}

# ----------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------
main() {
    local run_install=false

    # Parse wrapper flags
    local arg
    for arg in "$@"; do
        if handle_wrapper_flags "$arg"; then
            return 0
        fi
        [[ "$arg" == "--install" ]] && run_install=true
    done

    # Find symfluence.py
    local symfluence_script
    if ! symfluence_script=$(find_symfluence_script); then
        print_error "symfluence.py not found"
        echo
        show_symfluence_help
        exit 1
    fi

    # Find Python interpreter
    local python_cmd
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found"
        print_info  "Please install or load Python ${MIN_PYTHON_VERSION} or later"
        exit 1
    fi

    local symfluence_dir
    symfluence_dir=$(dirname "$symfluence_script")

    # ---------------- Installation mode (enhanced) ----------------
    if [[ "$run_install" == "true" ]]; then
        print_info "SYMFLUENCE installation mode"
        echo ""
        print_info "Prerequisites:"
        print_info "  - Python 3.11+"
        print_info "  - R (optional, for rpy2 features)"
        print_info "  - Required libs/modules (xz, bzip2, libtirpc, zlib, netcdf, gdal, etc.)"
        echo ""

        # Create venv if needed
        local venv_path="${symfluence_dir}/venv"
        if [[ ! -d "$venv_path" ]]; then
            print_info "Creating Python virtual environment..."
            if ! $python_cmd -m venv "$venv_path"; then
                print_error "Failed to create virtual environment"
                exit 1
            fi
        fi

        # Activate venv
        source "${venv_path}/bin/activate"

        # Clear PYTHONPATH to isolate venv
        if [[ -n "$PYTHONPATH" ]]; then
            print_warning "Clearing PYTHONPATH to isolate venv"
            export PYTHONPATH=""
        fi
        # Make clearing persistent for future activations
        if ! grep -q "Clear PYTHONPATH" "${venv_path}/bin/activate"; then
            cat >> "${venv_path}/bin/activate" << 'EOF'

# Clear PYTHONPATH to prevent system package conflicts
if [ -n "$PYTHONPATH" ]; then
    export _OLD_SYMFLUENCE_PYTHONPATH="$PYTHONPATH"
    unset PYTHONPATH
fi
EOF
        fi

        print_info "Upgrading pip and preparing environment..."
        pip install --upgrade pip

        setup_r_environment || print_warning "R setup had issues, continuing..."

        if [[ -f "${symfluence_dir}/requirements.txt" ]]; then
            # Use enhanced installer that handles rpy2/GDAL specially
            install_python_requirements "${symfluence_dir}/requirements.txt" "false" || {
                print_error "Dependency installation failed"; exit 1;
            }
        else
            print_warning "requirements.txt not found - installing a minimal set..."
            pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil || {
                print_error "Failed to install minimal dependencies"; exit 1;
            }
            print_info "Attempting to install rpy2 (optional)..."
            pip install rpy2 || print_warning "rpy2 installation failed (continuing)"
            command -v gdal-config >/dev/null 2>&1 && install_gdal_python || true
        fi

        print_success "Python environment setup complete"

        # External tools (mirrors your existing flow)
        cd "$symfluence_dir"
        print_info "Installing external tools..."
        $python_cmd "$SYMFLUENCE_SCRIPT" --get_executables
        print_info "Validating installation..."
        $python_cmd "$SYMFLUENCE_SCRIPT" --validate_binaries

        echo ""
        print_success "Installation complete!"
        print_info "To use SYMFLUENCE: source ${venv_path}/bin/activate"
        exit 0
    fi

    # ---------------- Normal execution ----------------
    check_virtual_env "$symfluence_script"

    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found"
        exit 1
    fi

    # Change to SYMFLUENCE directory if needed
    if [[ "$(dirname "$symfluence_script")" != "." ]]; then
        cd "$(dirname "$symfluence_script")"
    fi

    exec "$python_cmd" "$SYMFLUENCE_SCRIPT" "$@"
}

# Trap signals and run
trap 'echo -e "\nInterrupted"; exit 130' INT TERM
main "$@"
