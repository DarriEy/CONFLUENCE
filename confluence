#!/bin/bash
#
# CONFLUENCE Shell Wrapper with Python Environment Management
# 
# This script provides a convenient command-line interface for CONFLUENCE
# without requiring users to type "python CONFLUENCE.py" each time.
#
# Usage: confluence [options]
# Example: confluence --calibrate_model --debug
#

set -e  # Exit on any error

# Configuration
SCRIPT_NAME="confluence"
CONFLUENCE_SCRIPT="CONFLUENCE.py"
MIN_PYTHON_VERSION="3.8"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Function to print colored output
print_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

print_info() {
    echo -e "${BLUE}Info:${NC} $1"
}

print_success() {
    echo -e "${GREEN}Success:${NC} $1"
}

# Function to auto-detect and setup R environment for rpy2
setup_r_environment() {
    print_info "Auto-detecting R environment..."
    
    # Check if R is available
    if ! command -v R >/dev/null 2>&1; then
        print_error "R is not available in PATH"
        print_info "Please load R module before running installation, e.g.:"
        print_info "  module load r/4.5.0  # or your platform's R module"
        return 1
    fi
    
    local r_version=$(R --version | head -1)
    print_success "Found R: $r_version"
    
    # Set R_HOME if not already set
    if [[ -z "$R_HOME" ]]; then
        print_info "R_HOME not set, auto-detecting..."
        local detected_r_home=$(R RHOME 2>/dev/null)
        if [[ -n "$detected_r_home" && -d "$detected_r_home" ]]; then
            export R_HOME="$detected_r_home"
            print_success "Set R_HOME=$R_HOME"
        else
            print_warning "Could not detect R_HOME"
            print_info "You may need to set it manually: export R_HOME=\$(R RHOME)"
        fi
    else
        print_success "R_HOME already set: $R_HOME"
    fi
    
    # Add R lib to LD_LIBRARY_PATH if not already there
    if [[ -n "$R_HOME" && -d "$R_HOME/lib" ]]; then
        if [[ ":$LD_LIBRARY_PATH:" != *":$R_HOME/lib:"* ]]; then
            export LD_LIBRARY_PATH="$R_HOME/lib:$LD_LIBRARY_PATH"
            print_info "Added $R_HOME/lib to LD_LIBRARY_PATH"
        fi
    fi
    
    # Check for required libraries for rpy2 compilation
    check_rpy2_dependencies
    
    return 0
}

# Function to check for libraries needed by rpy2
check_rpy2_dependencies() {
    print_info "Checking for libraries required by rpy2..."
    
    local missing_libs=()
    local found_libs=()
    
    # Libraries that rpy2 commonly needs
    local required_libs=("lzma" "bz2" "z")
    
    # Check using ldconfig if available
    if command -v ldconfig >/dev/null 2>&1; then
        for lib in "${required_libs[@]}"; do
            if ldconfig -p 2>/dev/null | grep -q "lib${lib}\.so"; then
                found_libs+=("$lib")
            else
                missing_libs+=("$lib")
            fi
        done
    else
        # Alternative: check common library paths
        local lib_paths=("/usr/lib" "/usr/lib64" "/lib" "/lib64")
        if [[ -n "$LD_LIBRARY_PATH" ]]; then
            IFS=':' read -ra ADDITIONAL_PATHS <<< "$LD_LIBRARY_PATH"
            lib_paths+=("${ADDITIONAL_PATHS[@]}")
        fi
        
        for lib in "${required_libs[@]}"; do
            local found=false
            for path in "${lib_paths[@]}"; do
                if [[ -f "$path/lib${lib}.so" ]] || [[ -f "$path/lib${lib}.a" ]]; then
                    found=true
                    break
                fi
            done
            if $found; then
                found_libs+=("$lib")
            else
                missing_libs+=("$lib")
            fi
        done
    fi
    
    if [[ ${#found_libs[@]} -gt 0 ]]; then
        print_success "Found libraries: ${found_libs[*]}"
    fi
    
    if [[ ${#missing_libs[@]} -gt 0 ]]; then
        print_warning "Could not detect libraries: ${missing_libs[*]}"
        print_info "These libraries may be required for rpy2 compilation."
        print_info "If you have loaded modules providing these libraries, they should work."
        print_info "Common module names: xz, bzip2, libtirpc, zlib"
        print_info ""
        print_info "If installation fails, try loading additional modules or using ABI mode:"
        print_info "  export RPY2_CFFI_MODE=ABI"
    fi
    
    return 0
}

# Function to install Python packages with R environment
install_python_requirements() {
    local requirements_file="$1"
    local use_break_system_packages="${2:-true}"
    
    if [[ ! -f "$requirements_file" ]]; then
        print_error "Requirements file not found: $requirements_file"
        return 1
    fi
    
    # Set up pip flags based on whether we're in a venv/conda
    local pip_flags=""
    if [[ -z "$VIRTUAL_ENV" ]] && [[ -z "$CONDA_DEFAULT_ENV" ]]; then
        if [[ "$use_break_system_packages" == "true" ]]; then
            pip_flags="--break-system-packages"
        fi
    fi
    
    print_info "Installing Python dependencies from: $requirements_file"
    print_info "This may take several minutes, especially for packages like rpy2..."
    print_info "Note: Using pip --isolated to bypass platform wheelhouse and use PyPI"
    echo ""
    
    # Default to API mode for better performance
    if [[ -z "$RPY2_CFFI_MODE" ]]; then
        export RPY2_CFFI_MODE=API
        print_info "Using RPY2_CFFI_MODE=API (better performance)"
    else
        print_info "Using user-specified RPY2_CFFI_MODE=$RPY2_CFFI_MODE"
    fi
    
    # Try to install with current environment
    # Use --isolated to ignore Compute Canada's pip configuration completely
    # This forces pip to use only PyPI with no platform-specific wheels
    if pip install --isolated --index-url https://pypi.org/simple --no-cache-dir -r "$requirements_file" $pip_flags; then
        print_success "All dependencies installed successfully"
        return 0
    else
        local exit_code=$?
        print_error "Installation failed with RPY2_CFFI_MODE=$RPY2_CFFI_MODE"
        
        # If we were in API mode and it failed, try ABI mode
        if [[ "$RPY2_CFFI_MODE" == "API" ]]; then
            echo ""
            print_warning "API mode installation failed. This is common on HPC systems."
            print_info "Retrying with RPY2_CFFI_MODE=ABI (more compatible, slightly slower)..."
            echo ""
            
            export RPY2_CFFI_MODE=ABI
            
            if pip install --isolated --index-url https://pypi.org/simple --no-cache-dir -r "$requirements_file" $pip_flags; then
                print_success "Dependencies installed successfully in ABI mode"
                print_info "Note: rpy2 is using ABI mode. This is fully functional but slightly slower than API mode."
                return 0
            fi
        fi
        
        # Both attempts failed
        echo ""
        print_error "Failed to install dependencies"
        echo ""
        print_info "Troubleshooting steps:"
        print_info "1. Verify R is loaded and accessible:"
        print_info "     R --version"
        print_info "     echo \$R_HOME"
        print_info ""
        print_info "2. Ensure required library modules are loaded, e.g.:"
        print_info "     module load xz bzip2 libtirpc  # names vary by platform"
        print_info ""
        print_info "3. Try forcing ABI mode before installation:"
        print_info "     export RPY2_CFFI_MODE=ABI"
        print_info "     pip install -r requirements.txt --break-system-packages"
        print_info ""
        print_info "4. Check if R has required development libraries:"
        print_info "     ls \$R_HOME/lib/"
        echo ""
        
        return $exit_code
    fi
}

# Function to find CONFLUENCE.py
find_confluence_script() {
    local script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")
    local search_paths=(
        "${script_dir}/${CONFLUENCE_SCRIPT}"
        "${script_dir}/../${CONFLUENCE_SCRIPT}"
        "./${CONFLUENCE_SCRIPT}"
        "${PWD}/${CONFLUENCE_SCRIPT}"
    )
    
    # Check if CONFLUENCE_CODE_DIR environment variable is set
    if [[ -n "${CONFLUENCE_CODE_DIR}" ]]; then
        search_paths=("${CONFLUENCE_CODE_DIR}/${CONFLUENCE_SCRIPT}" "${search_paths[@]}")
    fi
    
    for path in "${search_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    return 1
}

# Function to find suitable Python interpreter
find_python() {
    local python_candidates=("python3" "python")
    local python_cmd=""
    
    for cmd in "${python_candidates[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            # Check Python version
            local version=$($cmd -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null)
            if [[ $? -eq 0 ]]; then
                # Compare version (basic comparison for major.minor)
                if python3 -c "
import sys
current = tuple(map(int, '$version'.split('.')))
required = tuple(map(int, '$MIN_PYTHON_VERSION'.split('.')))
sys.exit(0 if current >= required else 1)
" 2>/dev/null; then
                    python_cmd="$cmd"
                    break
                fi
            fi
        fi
    done
    
    if [[ -z "$python_cmd" ]]; then
        return 1
    fi
    
    echo "$python_cmd"
    return 0
}

# Function to check if Python dependencies are satisfied
check_python_dependencies() {
    local python_cmd="$1"
    
    # Try to import required packages
    if ! $python_cmd -c "
import sys
required_packages = ['yaml', 'numpy', 'pandas', 'geopandas', 'rasterio', 'netCDF4']
missing = []
for pkg in required_packages:
    try:
        __import__(pkg)
    except ImportError:
        missing.append(pkg)
if missing:
    print(f'Missing packages: {missing}')
    sys.exit(1)
" 2>/dev/null; then
        return 1
    fi
    return 0
}

# Function to verify all dependencies from requirements.txt
verify_all_dependencies() {
    local python_cmd="$1"
    local requirements_file="$2"
    
    if [[ ! -f "$requirements_file" ]]; then
        # No requirements.txt, just do basic check
        check_python_dependencies "$python_cmd"
        return $?
    fi
    
    print_info "Verifying all dependencies from requirements.txt..."
    
    # Try to import critical packages that CONFLUENCE actually needs
    if ! $python_cmd -c "
import sys
critical_packages = ['numpy', 'pandas', 'geopandas', 'rasterio', 'netCDF4', 'yaml', 'xarray']
missing = []
for pkg in critical_packages:
    try:
        __import__(pkg)
    except ImportError:
        missing.append(pkg)

if missing:
    print(f'Missing critical packages: {missing}', file=sys.stderr)
    sys.exit(1)
" 2>/dev/null; then
        return 1  # Only fail if critical packages are actually missing
    fi
    
    # pip check is informational only - don't fail on it
    if ! $python_cmd -m pip check >/dev/null 2>&1; then
        print_info "Note: pip check reported some warnings (this is often harmless)"
    fi
    
    return 0
}

# Function to check and activate virtual environment
check_virtual_env() {
    local confluence_dir=$(dirname "$1")
    local venv_paths=(
        "${confluence_dir}/venv"
        "${confluence_dir}/.venv" 
        "${confluence_dir}/env"
        "${confluence_dir}/.env"
        "${HOME}/.confluence/venv"
    )
    
    # Check if we're already in a virtual environment
    if [[ -n "${VIRTUAL_ENV}" ]]; then
        print_info "Using active virtual environment: ${VIRTUAL_ENV}"
        return 0
    fi
    
    # Look for virtual environment
    for venv_path in "${venv_paths[@]}"; do
        if [[ -f "${venv_path}/bin/activate" ]]; then
            print_info "Found virtual environment: ${venv_path}"
            print_info "Activating virtual environment..."
            source "${venv_path}/bin/activate"
            return 0
        fi
    done
    
    # No virtual environment found - continue with system Python
    return 0
}

# Function to setup and verify Python environment for install mode
setup_install_env() {
    local confluence_dir="$1"
    local python_cmd="$2"
    local venv_path="${confluence_dir}/venv"
    local requirements_file="${confluence_dir}/requirements.txt"
    
    print_info "Setting up Python environment for installation..."
    echo ""
    
    # Setup R environment first (needed for rpy2)
    if ! setup_r_environment; then
        print_error "R environment setup failed"
        return 1
    fi
    
    echo ""
    
    # Check if we're in a conda environment
    if [[ -n "${CONDA_DEFAULT_ENV}" ]]; then
        print_info "Running in conda environment: ${CONDA_DEFAULT_ENV}"
        print_info "Will install dependencies in current conda environment"
        echo ""
        
        if [[ -f "$requirements_file" ]]; then
            if ! install_python_requirements "$requirements_file" "false"; then
                return 1
            fi
        else
            print_warning "requirements.txt not found at: $requirements_file"
            return 1
        fi
        
        return 0
    fi
    
    # Check if venv exists
    if [[ -d "$venv_path" ]]; then
        print_info "Virtual environment exists at: $venv_path"
        
        # Activate it
        if [[ -f "${venv_path}/bin/activate" ]]; then
            print_info "Activating existing virtual environment..."
            source "${venv_path}/bin/activate"
            
            # Update python_cmd to use venv python
            python_cmd=$(which python3 || which python)
            
            # Verify all dependencies
            if verify_all_dependencies "$python_cmd" "$requirements_file"; then
                print_success "All dependencies verified in existing environment"
                return 0
            else
                print_warning "Dependencies missing or outdated in existing environment"
                print_info "Reinstalling dependencies..."
                echo ""
                
                pip install --upgrade pip
                
                if [[ -f "$requirements_file" ]]; then
                    if ! install_python_requirements "$requirements_file" "false"; then
                        return 1
                    fi
                else
                    print_warning "requirements.txt not found - installing basic dependencies..."
                    if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil rpy2; then
                        print_error "Failed to install dependencies"
                        return 1
                    fi
                fi
                
                print_success "Dependencies updated successfully"
                return 0
            fi
        else
            print_error "Virtual environment activation script not found"
            return 1
        fi
    else
        # Create new virtual environment
        print_info "Creating new virtual environment: $venv_path"
        
        #pyenv install 3.11.0
        #pyenv local 3.11.0
        
        if ! $python_cmd -m venv "$venv_path" python=3.11; then
            print_error "Failed to create virtual environment"
            return 1
        fi
        
        print_success "Virtual environment created"
        
        # Activate it
        source "${venv_path}/bin/activate"
        
        # Update python_cmd to use venv python
        python_cmd=$(which python3 || which python)
        
        # Upgrade pip
        print_info "Upgrading pip..."
        pip install --upgrade pip
        
        echo ""
        
        # Install dependencies
        if [[ -f "$requirements_file" ]]; then
            if ! install_python_requirements "$requirements_file" "false"; then
                return 1
            fi
        else
            print_warning "requirements.txt not found - installing basic dependencies..."
            if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil rpy2; then
                print_error "Failed to install dependencies"
                return 1
            fi
        fi
        
        print_success "Python environment setup complete"
        
        # Save activation command for future reference
        echo "# To activate CONFLUENCE environment:" > "${confluence_dir}/.confluence_env"
        echo "source ${venv_path}/bin/activate" >> "${confluence_dir}/.confluence_env"
        
        return 0
    fi
}

# Function to create virtual environment if needed (for non-install mode)
setup_python_env() {
    local confluence_dir="$1"
    local python_cmd="$2"
    
    # Check if dependencies are already satisfied
    if check_python_dependencies "$python_cmd"; then
        return 0  # All good
    fi
    
    print_warning "Some Python dependencies are missing"
    
    # Check if we can create a virtual environment
    if [[ -n "${VIRTUAL_ENV}" ]] || [[ -n "${CONDA_DEFAULT_ENV}" ]]; then
        print_info "In a virtual environment - you may need to install packages manually:"
        print_info "pip install -r requirements.txt"
        return 1
    fi
    
    # Offer to create virtual environment
    read -p "Create Python virtual environment and install dependencies? [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local venv_path="${confluence_dir}/venv"
        
        print_info "Creating virtual environment: $venv_path"
        if ! $python_cmd -m venv "$venv_path"; then
            print_error "Failed to create virtual environment"
            return 1
        fi
        
        # Activate environment
        source "${venv_path}/bin/activate"
        
        # Install dependencies
        print_info "Installing Python dependencies..."
        pip install --upgrade pip
        
        # Setup R environment for rpy2
        if ! setup_r_environment; then
            print_warning "R environment setup had issues, continuing anyway..."
        fi
        
        # Check if requirements.txt exists and use it
        local requirements_file="${confluence_dir}/requirements.txt"
        if [[ -f "$requirements_file" ]]; then
            print_info "Found requirements.txt - installing all dependencies..."
            if ! install_python_requirements "$requirements_file" "false"; then
                print_error "Failed to install dependencies from requirements.txt"
                return 1
            fi
        else
            print_warning "requirements.txt not found - installing basic dependencies..."
            if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil rpy2; then
                print_error "Failed to install dependencies"
                return 1
            fi
        fi
        
        print_success "Python environment setup complete"
        
        # Save activation command for future reference
        echo "# To activate CONFLUENCE environment:" > "${confluence_dir}/.confluence_env"
        echo "source ${venv_path}/bin/activate" >> "${confluence_dir}/.confluence_env"
        
        return 0
    fi
    
    return 1
}

# Function to show help if CONFLUENCE.py is not found
show_confluence_help() {
    cat << EOF
${SCRIPT_NAME}: CONFLUENCE Python script not found

This wrapper script looks for CONFLUENCE.py in the following locations:
  - Current directory and parent directories
  - Path specified by CONFLUENCE_CODE_DIR environment variable

To fix this issue:
1. Run this script from the CONFLUENCE project directory, or
2. Set the CONFLUENCE_CODE_DIR environment variable:
   export CONFLUENCE_CODE_DIR=/path/to/confluence
3. Or create a symlink to this script from the CONFLUENCE directory

For more information about CONFLUENCE, visit:
https://github.com/DarriEy/CONFLUENCE
EOF
}

# Function to handle special wrapper-only flags
handle_wrapper_flags() {
    case "$1" in
        --wrapper-help)
            cat << EOF
CONFLUENCE Shell Wrapper Help

This wrapper provides convenient access to CONFLUENCE without typing 'python CONFLUENCE.py'.

Wrapper-specific options:
  --wrapper-help     Show this help message
  --wrapper-info     Show wrapper and environment information
  --wrapper-debug    Run wrapper in debug mode
  --install          Set up Python environment and install external tools

All other options are passed directly to CONFLUENCE.py.
See 'confluence --help' for CONFLUENCE-specific options.
EOF
            exit 0
            ;;
        --wrapper-info)
            local confluence_script=$(find_confluence_script)
            local python_cmd=$(find_python)
            
            echo "CONFLUENCE Wrapper Information"
            echo "============================="
            echo "Wrapper script: $(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
            echo "CONFLUENCE.py: ${confluence_script:-'Not found'}"
            echo "Python command: ${python_cmd:-'Not found'}"
            echo "Python version: $(${python_cmd} --version 2>/dev/null || echo 'Unknown')"
            echo "Virtual env: ${VIRTUAL_ENV:-'None active'}"
            echo "Conda env: ${CONDA_DEFAULT_ENV:-'None active'}"
            echo "Working directory: $(pwd)"
            echo "CONFLUENCE_CODE_DIR: ${CONFLUENCE_CODE_DIR:-'Not set'}"
            echo ""
            echo "R Environment:"
            echo "  R available: $(command -v R >/dev/null 2>&1 && echo 'Yes' || echo 'No')"
            echo "  R_HOME: ${R_HOME:-'Not set'}"
            if command -v R >/dev/null 2>&1; then
                echo "  R version: $(R --version 2>/dev/null | head -1)"
            fi
            exit 0
            ;;
        --wrapper-debug)
            set -x  # Enable debug mode
            return 1  # Continue processing
            ;;
        --install)
            return 1  # Let main() handle this
            ;;
        *)
            return 1  # Not a wrapper flag, continue processing
            ;;
    esac
}

# Main execution function
main() {
    local run_install=false
    
    # Handle wrapper-specific flags
    for arg in "$@"; do
        if handle_wrapper_flags "$arg"; then
            # Flag was handled, exit
            return 0
        fi
        if [[ "$arg" == "--install" ]]; then
            run_install=true
        fi
    done
    
    # Find CONFLUENCE.py
    local confluence_script
    if ! confluence_script=$(find_confluence_script); then
        print_error "CONFLUENCE.py not found"
        echo
        show_confluence_help
        exit 1
    fi
    
    # Find Python interpreter
    local python_cmd
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found"
        print_info "Please install or load Python ${MIN_PYTHON_VERSION} or later"
        print_info "Example: module load python/3.11.5"
        exit 1
    fi
    
    local confluence_dir=$(dirname "$confluence_script")
    
    # Handle installation mode - use special setup
    if [[ "$run_install" == "true" ]]; then
        print_info "CONFLUENCE installation mode"
        echo ""
        print_info "Prerequisites:"
        print_info "  - Python 3.8+ (found: $(python3 --version 2>/dev/null || echo 'unknown'))"
        print_info "  - R (found: $(command -v R >/dev/null 2>&1 && R --version 2>/dev/null | head -1 || echo 'not found'))"
        print_info "  - Required library modules (xz, bzip2, etc.)"
        echo ""
        print_info "Make sure you have loaded all necessary modules before installation."
        print_info "Example module load commands (adjust for your platform):"
        print_info "  module load gcc openmpi python r netcdf gdal"
        echo ""
        
        # Set up Python environment specifically for install
        if ! setup_install_env "$confluence_dir" "$python_cmd"; then
            print_error "Failed to set up Python environment"
            exit 1
        fi
        
        # Update python_cmd to use the activated environment
        if ! python_cmd=$(find_python); then
            print_error "Python not found after environment setup"
            exit 1
        fi
        
        echo ""
        print_info "Python environment ready - proceeding to external tools..."
        echo ""
        
        # Run CONFLUENCE installation
        cd "$confluence_dir"
        print_info "Running CONFLUENCE external tool installation..."
        $python_cmd "$CONFLUENCE_SCRIPT" --get_executables
        
        echo ""
        print_info "Validating installation..."
        $python_cmd "$CONFLUENCE_SCRIPT" --validate_binaries
        
        echo ""
        print_success "Installation complete!"
        print_info ""
        print_info "To use CONFLUENCE in the future, activate the environment:"
        if [[ -n "${VIRTUAL_ENV}" ]]; then
            print_info "  source ${VIRTUAL_ENV}/bin/activate"
        elif [[ -f "${confluence_dir}/.confluence_env" ]]; then
            print_info "  source ${confluence_dir}/.confluence_env"
        fi
        exit 0
    fi
    
    # For normal execution, check and activate virtual environment
    check_virtual_env "$confluence_script"
    
    # Update python_cmd after potential venv activation
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found after environment setup"
        exit 1
    fi
    
    # Check dependencies (non-fatal)
    if ! check_python_dependencies "$python_cmd"; then
        print_warning "Some Python dependencies may be missing"
        print_info "Run 'confluence --install' to set up environment"
    fi
    
    # Change to the CONFLUENCE directory
    if [[ "$confluence_dir" != "." ]]; then
        cd "$confluence_dir"
    fi
    
    # Execute CONFLUENCE with all arguments
    exec "$python_cmd" "$CONFLUENCE_SCRIPT" "$@"
}

# Trap Ctrl+C and other signals
trap 'echo -e "\nInterrupted"; exit 130' INT TERM

# Run main function with all arguments
main "$@"
