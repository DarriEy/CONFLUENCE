#!/bin/bash
#
# CONFLUENCE Shell Wrapper with Python Environment Management
# 
# This script provides a convenient command-line interface for CONFLUENCE
# without requiring users to type "python CONFLUENCE.py" each time.
#
# Usage: confluence [options]
# Example: confluence --calibrate_model --debug
#

set -e  # Exit on any error

# Configuration
SCRIPT_NAME="confluence"
CONFLUENCE_SCRIPT="CONFLUENCE.py"
MIN_PYTHON_VERSION="3.8"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Function to print colored output
print_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

print_info() {
    echo -e "${BLUE}Info:${NC} $1"
}

print_success() {
    echo -e "${GREEN}Success:${NC} $1"
}

# Function to find CONFLUENCE.py
find_confluence_script() {
    local script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")
    local search_paths=(
        "${script_dir}/${CONFLUENCE_SCRIPT}"
        "${script_dir}/../${CONFLUENCE_SCRIPT}"
        "./${CONFLUENCE_SCRIPT}"
        "${PWD}/${CONFLUENCE_SCRIPT}"
    )
    
    # Check if CONFLUENCE_CODE_DIR environment variable is set
    if [[ -n "${CONFLUENCE_CODE_DIR}" ]]; then
        search_paths=("${CONFLUENCE_CODE_DIR}/${CONFLUENCE_SCRIPT}" "${search_paths[@]}")
    fi
    
    for path in "${search_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    return 1
}

# Function to find suitable Python interpreter
find_python() {
    local python_candidates=("python3" "python")
    local python_cmd=""
    
    for cmd in "${python_candidates[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            # Check Python version
            local version=$($cmd -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null)
            if [[ $? -eq 0 ]]; then
                # Compare version (basic comparison for major.minor)
                if python3 -c "
import sys
current = tuple(map(int, '$version'.split('.')))
required = tuple(map(int, '$MIN_PYTHON_VERSION'.split('.')))
sys.exit(0 if current >= required else 1)
" 2>/dev/null; then
                    python_cmd="$cmd"
                    break
                fi
            fi
        fi
    done
    
    if [[ -z "$python_cmd" ]]; then
        return 1
    fi
    
    echo "$python_cmd"
    return 0
}

# Function to check if Python dependencies are satisfied
check_python_dependencies() {
    local python_cmd="$1"
    
    # Try to import required packages
    if ! $python_cmd -c "
import sys
required_packages = ['yaml', 'numpy', 'pandas', 'geopandas', 'rasterio', 'netCDF4']
missing = []
for pkg in required_packages:
    try:
        __import__(pkg)
    except ImportError:
        missing.append(pkg)
if missing:
    print(f'Missing packages: {missing}')
    sys.exit(1)
" 2>/dev/null; then
        return 1
    fi
    return 0
}

# Function to check and activate virtual environment
check_virtual_env() {
    local confluence_dir=$(dirname "$1")
    local venv_paths=(
        "${confluence_dir}/venv"
        "${confluence_dir}/.venv" 
        "${confluence_dir}/env"
        "${confluence_dir}/.env"
        "${HOME}/.confluence/venv"
    )
    
    # Check if we're already in a virtual environment
    if [[ -n "${VIRTUAL_ENV}" ]]; then
        print_info "Using active virtual environment: ${VIRTUAL_ENV}"
        return 0
    fi
    
    # Look for virtual environment
    for venv_path in "${venv_paths[@]}"; do
        if [[ -f "${venv_path}/bin/activate" ]]; then
            print_info "Found virtual environment: ${venv_path}"
            print_info "Activating virtual environment..."
            source "${venv_path}/bin/activate"
            return 0
        fi
    done
    
    # No virtual environment found - continue with system Python
    return 0
}

# Function to create virtual environment if needed
setup_python_env() {
    local confluence_dir="$1"
    local python_cmd="$2"
    
    # Check if dependencies are already satisfied
    if check_python_dependencies "$python_cmd"; then
        return 0  # All good
    fi
    
    print_warning "Some Python dependencies are missing"
    
    # Check if we can create a virtual environment
    if [[ -n "${VIRTUAL_ENV}" ]] || [[ -n "${CONDA_DEFAULT_ENV}" ]]; then
        print_info "In a virtual environment - you may need to install packages manually:"
        print_info "pip install -r requirements.txt"
        return 1
    fi
    
    # Offer to create virtual environment
    read -p "Create Python virtual environment and install dependencies? [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local venv_path="${confluence_dir}/venv"
        
        print_info "Creating virtual environment: $venv_path"
        if ! $python_cmd -m venv "$venv_path"; then
            print_error "Failed to create virtual environment"
            return 1
        fi
        
        # Activate environment
        source "${venv_path}/bin/activate"
        
        # Install dependencies
        print_info "Installing Python dependencies..."
        pip install --upgrade pip
        
        # Check if requirements.txt exists and use it, otherwise install basic packages
        local requirements_file="${confluence_dir}/requirements.txt"
        if [[ -f "$requirements_file" ]]; then
            print_info "Found requirements.txt - installing all dependencies..."
            if ! pip install -r "$requirements_file"; then
                print_error "Failed to install dependencies from requirements.txt"
                return 1
            fi
        else
            print_warning "requirements.txt not found - installing basic dependencies..."
            if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil rpy2; then
                print_error "Failed to install dependencies"
                return 1
            fi
        fi
        
        print_success "Python environment setup complete"
        
        # Save activation command for future reference
        echo "# To activate CONFLUENCE environment:" > "${confluence_dir}/.confluence_env"
        echo "source ${venv_path}/bin/activate" >> "${confluence_dir}/.confluence_env"
        
        return 0
    fi
    
    return 1
}

# Function to show help if CONFLUENCE.py is not found
show_confluence_help() {
    cat << EOF
${SCRIPT_NAME}: CONFLUENCE Python script not found

This wrapper script looks for CONFLUENCE.py in the following locations:
  - Current directory and parent directories
  - Path specified by CONFLUENCE_CODE_DIR environment variable

To fix this issue:
1. Run this script from the CONFLUENCE project directory, or
2. Set the CONFLUENCE_CODE_DIR environment variable:
   export CONFLUENCE_CODE_DIR=/path/to/confluence
3. Or create a symlink to this script from the CONFLUENCE directory

For more information about CONFLUENCE, visit:
https://github.com/DarriEy/CONFLUENCE
EOF
}

# Function to handle special wrapper-only flags
handle_wrapper_flags() {
    case "$1" in
        --wrapper-help)
            cat << EOF
CONFLUENCE Shell Wrapper Help

This wrapper provides convenient access to CONFLUENCE without typing 'python CONFLUENCE.py'.

Wrapper-specific options:
  --wrapper-help     Show this help message
  --wrapper-info     Show wrapper and environment information
  --wrapper-debug    Run wrapper in debug mode
  --install          Set up Python environment and install external tools

All other options are passed directly to CONFLUENCE.py.
See 'confluence --help' for CONFLUENCE-specific options.
EOF
            exit 0
            ;;
        --wrapper-info)
            local confluence_script=$(find_confluence_script)
            local python_cmd=$(find_python)
            
            echo "CONFLUENCE Wrapper Information"
            echo "============================="
            echo "Wrapper script: $(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
            echo "CONFLUENCE.py: ${confluence_script:-'Not found'}"
            echo "Python command: ${python_cmd:-'Not found'}"
            echo "Python version: $(${python_cmd} --version 2>/dev/null || echo 'Unknown')"
            echo "Virtual env: ${VIRTUAL_ENV:-'None active'}"
            echo "Working directory: $(pwd)"
            echo "CONFLUENCE_CODE_DIR: ${CONFLUENCE_CODE_DIR:-'Not set'}"
            exit 0
            ;;
        --wrapper-debug)
            set -x  # Enable debug mode
            return 1  # Continue processing
            ;;
        --install)
            return 1  # Let main() handle this
            ;;
        *)
            return 1  # Not a wrapper flag, continue processing
            ;;
    esac
}

# Main execution function
main() {
    local run_install=false
    
    # Handle wrapper-specific flags
    for arg in "$@"; do
        if handle_wrapper_flags "$arg"; then
            # Flag was handled, exit
            return 0
        fi
        if [[ "$arg" == "--install" ]]; then
            run_install=true
        fi
    done
    
    # Find CONFLUENCE.py
    local confluence_script
    if ! confluence_script=$(find_confluence_script); then
        print_error "CONFLUENCE.py not found"
        echo
        show_confluence_help
        exit 1
    fi
    
    # Find Python interpreter
    local python_cmd
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found"
        print_info "Please install Python ${MIN_PYTHON_VERSION} or later"
        exit 1
    fi
    
    # Check and activate virtual environment
    check_virtual_env "$confluence_script"
    
    # Update python_cmd after potential venv activation
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found after environment setup"
        exit 1
    fi
    
    # Handle installation mode
    if [[ "$run_install" == "true" ]]; then
        print_info "CONFLUENCE installation mode"
        
        # Set up Python environment
        confluence_dir=$(dirname "$confluence_script")
        if ! setup_python_env "$confluence_dir" "$python_cmd"; then
            print_warning "Python environment setup incomplete"
        fi
        
        # Update python command after environment setup
        if ! python_cmd=$(find_python); then
            print_error "Python not found after environment setup"
            exit 1
        fi
        
        # Run CONFLUENCE installation
        cd "$confluence_dir"
        print_info "Running CONFLUENCE external tool installation..."
        $python_cmd "$CONFLUENCE_SCRIPT" --get_executables
        
        print_info "Validating installation..."
        $python_cmd "$CONFLUENCE_SCRIPT" --validate_binaries
        
        print_success "Installation complete!"
        exit 0
    fi
    
    # Check dependencies (non-fatal)
    if ! check_python_dependencies "$python_cmd"; then
        print_warning "Some Python dependencies may be missing"
        print_info "Run 'confluence --install' to set up environment"
    fi
    
    # Change to the CONFLUENCE directory
    local confluence_dir=$(dirname "$confluence_script")
    if [[ "$confluence_dir" != "." ]]; then
        cd "$confluence_dir"
    fi
    
    # Execute CONFLUENCE with all arguments
    exec "$python_cmd" "$CONFLUENCE_SCRIPT" "$@"
}

# Trap Ctrl+C and other signals
trap 'echo -e "\nInterrupted"; exit 130' INT TERM

# Run main function
main "$@"