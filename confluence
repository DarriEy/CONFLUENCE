#!/usr/bin/env bash
#===============================================================================
# CONFLUENCE Shell Wrapper
#===============================================================================
# Description: Provides a convenient command-line interface for CONFLUENCE
#              with automatic Python environment management, dependency
#              installation, and R integration support.
#
# Usage:       confluence [options]
# Example:     confluence --calibrate_model --debug
#
# Repository:  https://github.com/DarriEy/CONFLUENCE
#
# Authors:     CONFLUENCE Development Team
# License:     See LICENSE file in the repository
#===============================================================================

set -euo pipefail  # Exit on error, undefined variables, and pipe failures
IFS=$'\n\t'        # Set safe Internal Field Separator

#===============================================================================
# GLOBAL CONFIGURATION
#===============================================================================

readonly SCRIPT_NAME="confluence"
readonly CONFLUENCE_SCRIPT="CONFLUENCE.py"
readonly MIN_PYTHON_VERSION="3.8"
readonly REQUIRED_PYTHON_VERSION="3.11"
readonly VENV_DIR_NAME="venv"

# Terminal color codes (only if output is to a terminal)
if [[ -t 1 ]]; then
    readonly COLOR_RED='\033[0;31m'
    readonly COLOR_GREEN='\033[0;32m'
    readonly COLOR_YELLOW='\033[1;33m'
    readonly COLOR_BLUE='\033[0;34m'
    readonly COLOR_RESET='\033[0m'
else
    readonly COLOR_RED=''
    readonly COLOR_GREEN=''
    readonly COLOR_YELLOW=''
    readonly COLOR_BLUE=''
    readonly COLOR_RESET=''
fi

#===============================================================================
# UTILITY FUNCTIONS - Output and Messaging
#===============================================================================

# Print error message to stderr
# Arguments:
#   $1: Error message
print_error() {
    echo -e "${COLOR_RED}Error:${COLOR_RESET} $1" >&2
}

# Print warning message to stderr
# Arguments:
#   $1: Warning message
print_warning() {
    echo -e "${COLOR_YELLOW}Warning:${COLOR_RESET} $1" >&2
}

# Print informational message
# Arguments:
#   $1: Info message
print_info() {
    echo -e "${COLOR_BLUE}Info:${COLOR_RESET} $1"
}

# Print success message
# Arguments:
#   $1: Success message
print_success() {
    echo -e "${COLOR_GREEN}Success:${COLOR_RESET} $1"
}

#===============================================================================
# PYTHON ENVIRONMENT DETECTION AND VALIDATION
#===============================================================================

# Compare two version strings
# Arguments:
#   $1: First version string (e.g., "3.11.5")
#   $2: Second version string (e.g., "3.8.0")
# Returns:
#   0 if $1 >= $2, 1 otherwise
version_compare() {
    local version1="$1"
    local version2="$2"
    
    # Split versions into arrays
    IFS='.' read -ra ver1_parts <<< "$version1"
    IFS='.' read -ra ver2_parts <<< "$version2"
    
    # Compare each part
    for i in {0..2}; do
        local v1="${ver1_parts[$i]:-0}"
        local v2="${ver2_parts[$i]:-0}"
        
        if (( v1 > v2 )); then
            return 0
        elif (( v1 < v2 )); then
            return 1
        fi
    done
    
    return 0  # Versions are equal
}

# Find a suitable Python interpreter
# Returns:
#   Prints the path to Python executable
#   Exit code 0 on success, 1 on failure
find_python() {
    local python_candidates=("python3" "python")
    local python_cmd=""
    
    # If in virtual environment, use that Python
    if [[ -n "${VIRTUAL_ENV:-}" ]]; then
        python_cmd="${VIRTUAL_ENV}/bin/python"
        if [[ -x "$python_cmd" ]]; then
            echo "$python_cmd"
            return 0
        fi
    fi
    
    # Try each candidate
    for candidate in "${python_candidates[@]}"; do
        if command -v "$candidate" &> /dev/null; then
            local version
            version=$("$candidate" -c 'import sys; print(".".join(map(str, sys.version_info[:3])))' 2>/dev/null || echo "0.0.0")
            
            if version_compare "$version" "$MIN_PYTHON_VERSION"; then
                python_cmd="$candidate"
                echo "$python_cmd"
                return 0
            fi
        fi
    done
    
    return 1
}

# Check if required Python dependencies are installed
# Arguments:
#   $1: Path to Python interpreter
# Returns:
#   0 if all critical dependencies are present, 1 otherwise
check_python_dependencies() {
    local python_cmd="$1"
    local critical_packages=("numpy" "pandas" "yaml")
    local missing_packages=()
    
    for package in "${critical_packages[@]}"; do
        if ! "$python_cmd" -c "import $package" &> /dev/null; then
            missing_packages+=("$package")
        fi
    done
    
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        print_warning "Missing Python packages: ${missing_packages[*]}"
        return 1
    fi
    
    return 0
}

#===============================================================================
# CONFLUENCE SCRIPT LOCATION AND DISCOVERY
#===============================================================================

# Find CONFLUENCE.py script in various standard locations
# Returns:
#   Prints the path to CONFLUENCE.py
#   Exit code 0 on success, 1 on failure
find_confluence_script() {
    local search_paths=()
    
    # Priority 1: CONFLUENCE_CODE_DIR environment variable
    if [[ -n "${CONFLUENCE_CODE_DIR:-}" ]]; then
        search_paths+=("${CONFLUENCE_CODE_DIR}/${CONFLUENCE_SCRIPT}")
    fi
    
    # Priority 2: Current directory
    search_paths+=("./${CONFLUENCE_SCRIPT}")
    
    # Priority 3: Parent directories (up to 3 levels)
    search_paths+=(
        "../${CONFLUENCE_SCRIPT}"
        "../../${CONFLUENCE_SCRIPT}"
        "../../../${CONFLUENCE_SCRIPT}"
    )
    
    # Priority 4: Script's directory and its parent
    local script_dir
    script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")
    search_paths+=(
        "${script_dir}/${CONFLUENCE_SCRIPT}"
        "${script_dir}/../${CONFLUENCE_SCRIPT}"
    )
    
    # Search all paths
    for path in "${search_paths[@]}"; do
        if [[ -f "$path" ]]; then
            readlink -f "$path" 2>/dev/null || realpath "$path" 2>/dev/null || echo "$path"
            return 0
        fi
    done
    
    return 1
}

#===============================================================================
# VIRTUAL ENVIRONMENT MANAGEMENT
#===============================================================================

# Check for and activate virtual environment if present
# Arguments:
#   $1: Path to CONFLUENCE.py script
check_virtual_env() {
    local confluence_script="$1"
    local confluence_dir
    confluence_dir=$(dirname "$confluence_script")
    local venv_path="${confluence_dir}/${VENV_DIR_NAME}"
    
    # Skip if already in a virtual environment
    if [[ -n "${VIRTUAL_ENV:-}" ]]; then
        return 0
    fi
    
    # Check if venv exists and activate it
    if [[ -d "$venv_path" ]] && [[ -f "${venv_path}/bin/activate" ]]; then
        print_info "Activating virtual environment: ${venv_path}"
        # shellcheck source=/dev/null
        source "${venv_path}/bin/activate"
        return 0
    fi
    
    return 0
}

#===============================================================================
# R ENVIRONMENT SETUP AND DETECTION
#===============================================================================

# Auto-detect and configure R environment for rpy2
# Returns:
#   0 on success, 1 on failure
setup_r_environment() {
    print_info "Auto-detecting R environment..."
    
    # Check if R is available
    if ! command -v R &> /dev/null; then
        print_error "R is not available in PATH"
        print_info "Please load R module before running installation, e.g.:"
        print_info "  module load r/4.5.0  # or your platform's R module"
        return 1
    fi
    
    local r_version
    r_version=$(R --version | head -1)
    print_success "Found R: ${r_version}"
    
    # Set R_HOME if not already set
    if [[ -z "${R_HOME:-}" ]]; then
        print_info "R_HOME not set, auto-detecting..."
        local detected_r_home
        detected_r_home=$(R RHOME 2>/dev/null)
        
        if [[ -n "$detected_r_home" ]] && [[ -d "$detected_r_home" ]]; then
            export R_HOME="$detected_r_home"
            print_success "Set R_HOME=${R_HOME}"
        else
            print_warning "Could not detect R_HOME"
            print_info "You may need to set it manually: export R_HOME=\$(R RHOME)"
        fi
    else
        print_success "R_HOME already set: ${R_HOME}"
    fi
    
    # Add R lib to LD_LIBRARY_PATH if not already present
    if [[ -n "${R_HOME:-}" ]] && [[ -d "${R_HOME}/lib" ]]; then
        if [[ ":${LD_LIBRARY_PATH:-}:" != *":${R_HOME}/lib:"* ]]; then
            export LD_LIBRARY_PATH="${R_HOME}/lib:${LD_LIBRARY_PATH:-}"
            print_info "Added ${R_HOME}/lib to LD_LIBRARY_PATH"
        fi
    fi
    
    # Set up compiler/linker flags for rpy2 compilation
    setup_rpy2_compiler_flags
    
    # Check for required libraries for rpy2 compilation
    check_rpy2_dependencies
    
    return 0
}

# Configure compiler flags for rpy2 by detecting library paths
# Returns:
#   0 on success
setup_rpy2_compiler_flags() {
    print_info "Setting up compiler environment for rpy2..."
    
    local lib_paths=()
    
    # Add paths from LD_LIBRARY_PATH
    if [[ -n "${LD_LIBRARY_PATH:-}" ]]; then
        IFS=':' read -ra paths <<< "$LD_LIBRARY_PATH"
        lib_paths+=("${paths[@]}")
    fi
    
    # On HPC systems, check for library paths in loaded modules
    local potential_lib_dirs=(
        "/usr/lib64"
        "/usr/lib"
        "/lib64"
        "/lib"
    )
    
    # Add Spack/module library paths if they exist
    if [[ -n "${LIBRARY_PATH:-}" ]]; then
        IFS=':' read -ra paths <<< "$LIBRARY_PATH"
        lib_paths+=("${paths[@]}")
    fi
    
    # Look for libraries in parent directories of loaded executables
    for prog in xz bzip2; do
        if command -v "$prog" &> /dev/null; then
            local prog_path
            prog_path=$(command -v "$prog")
            local prog_dir
            prog_dir=$(dirname "$prog_path")
            
            local potential_lib_path="${prog_dir}/../lib"
            if [[ -d "$potential_lib_path" ]]; then
                lib_paths+=("$(cd "$potential_lib_path" && pwd)")
            fi
            
            potential_lib_path="${prog_dir}/../lib64"
            if [[ -d "$potential_lib_path" ]]; then
                lib_paths+=("$(cd "$potential_lib_path" && pwd)")
            fi
        fi
    done
    
    # Build LDFLAGS and CFLAGS
    local ldflags=""
    local cflags=""
    local unique_paths=()
    
    # Remove duplicates and build flags
    for path in "${lib_paths[@]}"; do
        if [[ -d "$path" ]] && [[ ! " ${unique_paths[*]} " =~ " ${path} " ]]; then
            unique_paths+=("$path")
            ldflags="${ldflags} -L${path}"
            
            # Also add include path if it exists
            local inc_path="${path/lib/include}"
            if [[ -d "$inc_path" ]]; then
                cflags="${cflags} -I${inc_path}"
            fi
        fi
    done
    
    # Export flags for pip to use during compilation
    if [[ -n "$ldflags" ]]; then
        export LDFLAGS="${ldflags} ${LDFLAGS:-}"
        print_info "Set LDFLAGS for rpy2 compilation"
    fi
    
    if [[ -n "$cflags" ]]; then
        export CFLAGS="${cflags} ${CFLAGS:-}"
        print_info "Set CFLAGS for rpy2 compilation"
    fi
    
    return 0
}

# Check for libraries required by rpy2
# Returns:
#   0 on success (all libraries found or warnings issued)
check_rpy2_dependencies() {
    print_info "Checking for libraries required by rpy2..."
    
    local missing_libs=()
    local found_libs=()
    # Libraries that rpy2 commonly needs (including ICU for internationalization)
    local required_libs=("lzma" "bz2" "z" "tirpc" "icuuc" "icui18n")
    
    # Check using ldconfig if available
    if command -v ldconfig &> /dev/null; then
        for lib in "${required_libs[@]}"; do
            if ldconfig -p 2>/dev/null | grep -q "lib${lib}\.so"; then
                found_libs+=("$lib")
            else
                missing_libs+=("$lib")
            fi
        done
    else
        # Alternative: check common library paths plus module paths
        local lib_paths=("/usr/lib" "/usr/lib64" "/lib" "/lib64")
        
        # Add paths from environment variables
        if [[ -n "${LD_LIBRARY_PATH:-}" ]]; then
            IFS=':' read -ra additional_paths <<< "$LD_LIBRARY_PATH"
            lib_paths+=("${additional_paths[@]}")
        fi
        
        if [[ -n "${LIBRARY_PATH:-}" ]]; then
            IFS=':' read -ra additional_paths <<< "$LIBRARY_PATH"
            lib_paths+=("${additional_paths[@]}")
        fi
        
        for lib in "${required_libs[@]}"; do
            local found=false
            for path in "${lib_paths[@]}"; do
                if [[ -f "${path}/lib${lib}.so" ]] || [[ -f "${path}/lib${lib}.a" ]]; then
                    found=true
                    break
                fi
            done
            
            if [[ "$found" == "true" ]]; then
                found_libs+=("$lib")
            else
                missing_libs+=("$lib")
            fi
        done
    fi
    
    # Report findings
    if [[ ${#found_libs[@]} -gt 0 ]]; then
        print_success "Found libraries: ${found_libs[*]}"
    fi
    
    if [[ ${#missing_libs[@]} -gt 0 ]]; then
        print_warning "Could not detect libraries: ${missing_libs[*]}"
        print_info "These libraries are REQUIRED for rpy2 compilation."
        echo ""
        print_info "You must load modules providing these libraries before installation:"
        
        # Provide platform-specific guidance
        if [[ -n "${SLURM_CLUSTER_NAME:-}" ]]; then
            # On HPC systems
            print_info ""
            print_info "Example module load commands (adjust versions for your system):"
            for lib in "${missing_libs[@]}"; do
                case "$lib" in
                    lzma)
                        print_info "  module load xz"
                        ;;
                    bz2)
                        print_info "  module load bzip2"
                        ;;
                    tirpc)
                        print_info "  module load libtirpc"
                        ;;
                    z)
                        print_info "  module load zlib"
                        ;;
                    icuuc|icui18n)
                        print_info "  module load icu"
                        ;;
                esac
            done
        else
            print_info "Common module names: xz, bzip2, libtirpc, zlib, icu"
        fi
        
        echo ""
        print_info "After loading modules, rerun: ./confluence --install"
        echo ""
        print_warning "Installation will likely FAIL without these libraries!"
        echo ""
        
        # Give user a chance to see the message
        read -r -p "Press Enter to continue anyway, or Ctrl+C to abort and load modules..."
    fi
    
    return 0
}

#===============================================================================
# INSTALLATION AND DEPENDENCY MANAGEMENT
#===============================================================================

# Detect and install GDAL Python bindings matching system version
# Returns:
#   0 on success, 1 on failure
install_gdal_python() {
    print_info "Detecting system GDAL version..."
    
    # Check if gdal-config is available
    if ! command -v gdal-config &> /dev/null; then
        print_warning "gdal-config not found - GDAL module may not be loaded"
        print_info "Skipping GDAL Python bindings installation"
        return 0
    fi
    
    # Get GDAL version
    local gdal_version
    gdal_version=$(gdal-config --version 2>/dev/null)
    if [[ -z "$gdal_version" ]]; then
        print_warning "Could not detect GDAL version"
        print_info "Skipping GDAL Python bindings installation"
        return 0
    fi
    
    print_success "Found system GDAL version: ${gdal_version}"
    print_info "Installing matching GDAL Python bindings..."
    
    # Try to install exact version match
    if pip install "GDAL==${gdal_version}"; then
        print_success "Installed GDAL Python bindings version ${gdal_version}"
        return 0
    else
        print_warning "Could not install GDAL==${gdal_version}"
        
        # Try minor version (e.g., 3.9.1 -> try 3.9.0)
        local major_minor
        major_minor=$(echo "$gdal_version" | cut -d. -f1,2)
        print_info "Trying GDAL>=${major_minor}.0,<${major_minor}.99..."
        
        if pip install "GDAL>=${major_minor}.0,<${major_minor}.99"; then
            print_success "Installed GDAL Python bindings for ${major_minor} series"
            return 0
        else
            print_error "Failed to install GDAL Python bindings"
            print_info "You may need to install GDAL manually:"
            print_info "  pip install GDAL==${gdal_version}"
            return 1
        fi
    fi
}

# Install Python requirements from requirements.txt
# Arguments:
#   $1: Path to requirements.txt
#   $2: Use break-system-packages flag ("true" or "false")
# Returns:
#   0 on success, 1 on failure
install_python_requirements() {
    local requirements_file="$1"
    local use_break_system_packages="${2:-true}"
    
    if [[ ! -f "$requirements_file" ]]; then
        print_error "Requirements file not found: ${requirements_file}"
        return 1
    fi
    
    # Set up pip flags based on whether we're in a venv/conda
    local pip_flags=""
    if [[ -z "${VIRTUAL_ENV:-}" ]] && [[ -z "${CONDA_DEFAULT_ENV:-}" ]]; then
        if [[ "$use_break_system_packages" == "true" ]]; then
            pip_flags="--break-system-packages"
        fi
    fi
    
    print_info "Installing Python dependencies from: ${requirements_file}"
    print_info "This may take several minutes..."
    echo ""
    
    # Filter out GDAL and rpy2 from requirements - we'll install them separately
    # GDAL needs version detection, rpy2 is optional and may fail on some systems
    local temp_requirements="${requirements_file}.tmp"
    grep -v -iE "^(GDAL|rpy2)([>=<~!]|$)" "$requirements_file" > "$temp_requirements" 2>/dev/null || cp "$requirements_file" "$temp_requirements"
    
    local gdal_filtered=false
    local rpy2_filtered=false
    
    if ! cmp -s "$requirements_file" "$temp_requirements"; then
        if grep -q -iE "^GDAL([>=<~!]|$)" "$requirements_file"; then
            gdal_filtered=true
            print_info "Note: GDAL will be installed separately with auto-detected version"
        fi
        if grep -q -iE "^rpy2([>=<~!]|$)" "$requirements_file"; then
            rpy2_filtered=true
            print_info "Note: rpy2 will be installed separately (optional)"
        fi
    fi
    
    # Default to API mode for better performance (only matters if rpy2 is installed)
    if [[ -z "${RPY2_CFFI_MODE:-}" ]]; then
        export RPY2_CFFI_MODE=API
    fi
    
    # Install from filtered requirements
    # shellcheck disable=SC2086
    if pip install -r "$temp_requirements" $pip_flags; then
        rm -f "$temp_requirements"
        
        # Now install GDAL separately with version detection
        if [[ "$gdal_filtered" == "true" ]]; then
            echo ""
            if ! install_gdal_python; then
                print_warning "GDAL Python bindings installation failed, but continuing..."
            fi
        fi
        
        # Try to install rpy2 separately - it's optional and may fail
        if [[ "$rpy2_filtered" == "true" ]]; then
            echo ""
            print_info "Attempting to install rpy2 (optional, may fail on some systems)..."
            print_info "Using RPY2_CFFI_MODE=${RPY2_CFFI_MODE}"
            # shellcheck disable=SC2086
            if pip install rpy2 $pip_flags; then
                print_success "rpy2 installed successfully"
            else
                print_warning "rpy2 installation failed - continuing without it"
                print_info "rpy2 enables R integration features"
                print_info "You can try installing it manually later if needed:"
                print_info "  source venv/bin/activate"
                print_info "  export RPY2_CFFI_MODE=ABI"
                print_info "  pip install rpy2"
            fi
        fi
        
        # Always try to install GDAL if gdal-config is available and not already installed
        # This handles cases where GDAL is not in requirements.txt but is needed
        if command -v gdal-config &> /dev/null; then
            echo ""
            if ! python -c "import osgeo.gdal" &> /dev/null; then
                print_info "GDAL not installed yet, attempting installation..."
                if ! install_gdal_python; then
                    print_warning "GDAL Python bindings installation failed"
                fi
            else
                print_success "GDAL Python bindings already installed"
            fi
        fi
        
        print_success "Python packages installed successfully"
        return 0
    else
        rm -f "$temp_requirements"
        print_error "Failed to install packages from requirements.txt"
        return 1
    fi
}

# Set up Python virtual environment and install dependencies
# Arguments:
#   $1: CONFLUENCE directory path
#   $2: Python command
# Returns:
#   0 on success, 1 on failure
setup_install_env() {
    local confluence_dir="$1"
    local python_cmd="$2"
    local venv_path="${confluence_dir}/${VENV_DIR_NAME}"
    
    print_info "Setting up Python environment in ${venv_path}..."
    
    # Check if already in a virtual environment
    if [[ -n "${VIRTUAL_ENV:-}" ]]; then
        print_info "Already in a virtual environment: ${VIRTUAL_ENV}"
        print_info "Using existing environment for installation"
        
        # Upgrade pip
        print_info "Upgrading pip..."
        if ! pip install --upgrade pip; then
            print_warning "Failed to upgrade pip, continuing anyway..."
        fi
        
        # Setup R environment for rpy2
        if ! setup_r_environment; then
            print_warning "R environment setup had issues, continuing anyway..."
        fi
        
        # Install requirements
        local requirements_file="${confluence_dir}/requirements.txt"
        if [[ -f "$requirements_file" ]]; then
            print_info "Found requirements.txt - installing all dependencies..."
            if ! install_python_requirements "$requirements_file" "false"; then
                print_error "Failed to install dependencies from requirements.txt"
                return 1
            fi
        else
            print_warning "requirements.txt not found - installing basic dependencies..."
            if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil; then
                print_error "Failed to install dependencies"
                return 1
            fi
            
            # Try to install GDAL with version matching
            echo ""
            if ! install_gdal_python; then
                print_warning "GDAL installation failed - you may need to install it manually"
            fi
            
            # Try to install rpy2 separately
            print_info "Attempting to install rpy2 (optional, may fail on some systems)..."
            if pip install rpy2; then
                print_success "rpy2 installed successfully"
            else
                print_warning "rpy2 installation failed - you can install it manually later if needed"
                print_info "To install rpy2 later: source venv/bin/activate && pip install rpy2"
            fi
        fi
        
        print_success "Python environment setup complete"
        return 0
    fi
    
    # Create new virtual environment if it doesn't exist
    if [[ ! -d "$venv_path" ]]; then
        print_info "Creating virtual environment..."
        if ! "$python_cmd" -m venv "$venv_path"; then
            print_error "Failed to create virtual environment"
            return 1
        fi
        print_success "Virtual environment created"
    else
        print_info "Virtual environment already exists"
    fi
    
    # Activate the virtual environment
    print_info "Activating virtual environment..."
    # shellcheck source=/dev/null
    if ! source "${venv_path}/bin/activate"; then
        print_error "Failed to activate virtual environment"
        return 1
    fi
    
    # Verify activation
    if [[ -z "${VIRTUAL_ENV:-}" ]]; then
        print_error "Virtual environment activation failed"
        return 1
    fi
    
    print_success "Virtual environment activated"
    
    # Upgrade pip
    print_info "Upgrading pip..."
    if ! pip install --upgrade pip; then
        print_warning "Failed to upgrade pip, continuing anyway..."
    fi
    
    # Setup R environment for rpy2
    if ! setup_r_environment; then
        print_warning "R environment setup had issues, continuing anyway..."
    fi
    
    # Install requirements
    local requirements_file="${confluence_dir}/requirements.txt"
    if [[ -f "$requirements_file" ]]; then
        print_info "Found requirements.txt - installing all dependencies..."
        if ! install_python_requirements "$requirements_file" "false"; then
            print_error "Failed to install dependencies from requirements.txt"
            return 1
        fi
    else
        print_warning "requirements.txt not found - installing basic dependencies..."
        if ! pip install numpy pandas geopandas rasterio netCDF4 PyYAML shapely rasterstats psutil; then
            print_error "Failed to install dependencies"
            return 1
        fi
        
        # Try to install GDAL with version matching
        echo ""
        if ! install_gdal_python; then
            print_warning "GDAL installation failed - you may need to install it manually"
        fi
        
        # Try to install rpy2 separately
        print_info "Attempting to install rpy2 (optional, may fail on some systems)..."
        if pip install rpy2; then
            print_success "rpy2 installed successfully"
        else
            print_warning "rpy2 installation failed - you can install it manually later if needed"
            print_info "To install rpy2 later: source venv/bin/activate && pip install rpy2"
        fi
    fi
    
    print_success "Python environment setup complete"
    
    # Save activation command for future reference
    cat > "${confluence_dir}/.confluence_env" << EOF
# To activate CONFLUENCE environment:
source ${venv_path}/bin/activate
EOF
    
    return 0
}

#===============================================================================
# WRAPPER-SPECIFIC COMMANDS AND HELP
#===============================================================================

# Display help message when CONFLUENCE.py is not found
show_confluence_help() {
    cat << EOF
${SCRIPT_NAME}: CONFLUENCE Python script not found

This wrapper script looks for CONFLUENCE.py in the following locations:
  - Current directory and parent directories
  - Path specified by CONFLUENCE_CODE_DIR environment variable

To fix this issue:
1. Run this script from the CONFLUENCE project directory, or
2. Set the CONFLUENCE_CODE_DIR environment variable:
   export CONFLUENCE_CODE_DIR=/path/to/confluence
3. Or create a symlink to this script from the CONFLUENCE directory

For more information about CONFLUENCE, visit:
https://github.com/DarriEy/CONFLUENCE
EOF
}

# Handle wrapper-specific command line flags
# Arguments:
#   $1: Command line argument
# Returns:
#   0 if flag was handled (exit wrapper)
#   1 if flag should be passed through to CONFLUENCE.py
handle_wrapper_flags() {
    case "$1" in
        --wrapper-help)
            cat << EOF
CONFLUENCE Shell Wrapper Help

This wrapper provides convenient access to CONFLUENCE without typing 'python CONFLUENCE.py'.

Wrapper-specific options:
  --wrapper-help     Show this help message
  --wrapper-info     Show wrapper and environment information
  --wrapper-debug    Run wrapper in debug mode
  --install          Set up Python environment and install external tools

All other options are passed directly to CONFLUENCE.py.
See 'confluence --help' for CONFLUENCE-specific options.
EOF
            exit 0
            ;;
            
        --wrapper-info)
            local confluence_script
            confluence_script=$(find_confluence_script) || confluence_script="Not found"
            
            local python_cmd
            python_cmd=$(find_python) || python_cmd="Not found"
            
            local python_version="Unknown"
            if [[ "$python_cmd" != "Not found" ]]; then
                python_version=$("$python_cmd" --version 2>&1 || echo "Unknown")
            fi
            
            local r_available="No"
            local r_version="N/A"
            if command -v R &> /dev/null; then
                r_available="Yes"
                r_version=$(R --version 2>/dev/null | head -1)
            fi
            
            cat << EOF
CONFLUENCE Wrapper Information
=============================
Wrapper script:      $(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")
CONFLUENCE.py:       ${confluence_script}
Python command:      ${python_cmd}
Python version:      ${python_version}
Virtual env:         ${VIRTUAL_ENV:-None active}
Conda env:           ${CONDA_DEFAULT_ENV:-None active}
Working directory:   $(pwd)
CONFLUENCE_CODE_DIR: ${CONFLUENCE_CODE_DIR:-Not set}

R Environment:
  R available:       ${r_available}
  R_HOME:            ${R_HOME:-Not set}
  R version:         ${r_version}
EOF
            exit 0
            ;;
            
        --wrapper-debug)
            set -x  # Enable bash debug mode
            return 1  # Continue processing
            ;;
            
        --install)
            return 1  # Let main() handle this
            ;;
            
        *)
            return 1  # Not a wrapper flag, continue processing
            ;;
    esac
}

#===============================================================================
# MAIN EXECUTION LOGIC
#===============================================================================

# Main entry point for the wrapper script
# Arguments:
#   $@: All command line arguments
main() {
    local run_install=false
    
    # Handle wrapper-specific flags
    for arg in "$@"; do
        if handle_wrapper_flags "$arg"; then
            # Flag was handled and script exited
            return 0
        fi
        
        if [[ "$arg" == "--install" ]]; then
            run_install=true
        fi
    done
    
    # Find CONFLUENCE.py
    local confluence_script
    if ! confluence_script=$(find_confluence_script); then
        print_error "CONFLUENCE.py not found"
        echo
        show_confluence_help
        exit 1
    fi
    
    # Find Python interpreter
    local python_cmd
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found"
        print_info "Please install or load Python ${MIN_PYTHON_VERSION} or later"
        print_info "Example: module load python/3.11.5"
        exit 1
    fi
    
    local confluence_dir
    confluence_dir=$(dirname "$confluence_script")
    
    # Handle installation mode
    if [[ "$run_install" == "true" ]]; then
        print_info "CONFLUENCE installation mode"
        echo ""
        print_info "Prerequisites:"
        print_info "  - Python 3.11+ (found: $("$python_cmd" --version 2>&1 || echo 'unknown'))"
        print_info "  - R (found: $(command -v R &> /dev/null && R --version 2>/dev/null | head -1 || echo 'not found'))"
        print_info "  - Required library modules (xz, bzip2, etc.)"
        echo ""
        print_info "Make sure you have loaded all necessary modules before installation."
        print_info "Example module load commands (adjust for your platform):"
        print_info "  module load gcc openmpi python/3.11 r netcdf gdal"
        echo ""
        
        # Set up Python environment
        if ! setup_install_env "$confluence_dir" "$python_cmd"; then
            print_error "Failed to set up Python environment"
            exit 1
        fi
        
        # Update python_cmd to use the activated environment
        if ! python_cmd=$(find_python); then
            print_error "Python not found after environment setup"
            exit 1
        fi
        
        echo ""
        print_info "Python environment ready - proceeding to external tools..."
        echo ""
        
        # Run CONFLUENCE installation
        cd "$confluence_dir" || exit 1
        print_info "Running CONFLUENCE external tool installation..."
        "$python_cmd" "$CONFLUENCE_SCRIPT" --get_executables
        
        echo ""
        print_info "Validating installation..."
        "$python_cmd" "$CONFLUENCE_SCRIPT" --validate_binaries
        
        echo ""
        print_success "Installation complete!"
        print_info ""
        print_info "To use CONFLUENCE in the future, activate the environment:"
        if [[ -n "${VIRTUAL_ENV:-}" ]]; then
            print_info "  source ${VIRTUAL_ENV}/bin/activate"
        elif [[ -f "${confluence_dir}/.confluence_env" ]]; then
            print_info "  source ${confluence_dir}/.confluence_env"
        fi
        exit 0
    fi
    
    # Normal execution mode: check and activate virtual environment
    check_virtual_env "$confluence_script"
    
    # Update python_cmd after potential venv activation
    if ! python_cmd=$(find_python); then
        print_error "Python ${MIN_PYTHON_VERSION}+ not found after environment setup"
        exit 1
    fi
    
    # Check dependencies (non-fatal)
    if ! check_python_dependencies "$python_cmd"; then
        print_warning "Some Python dependencies may be missing"
        print_info "Run 'confluence --install' to set up environment"
    fi
    
    # Change to the CONFLUENCE directory
    if [[ "$confluence_dir" != "." ]]; then
        cd "$confluence_dir" || exit 1
    fi
    
    # Execute CONFLUENCE with all arguments
    exec "$python_cmd" "$CONFLUENCE_SCRIPT" "$@"
}

#===============================================================================
# SCRIPT ENTRY POINT
#===============================================================================

# Trap signals for clean shutdown
trap 'echo -e "\nInterrupted"; exit 130' INT TERM

# Run main function with all command line arguments
main "$@"
